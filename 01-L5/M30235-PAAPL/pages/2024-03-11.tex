\taughtsession{Lecture}{Names, Bindings, Scopes and Memory Allocation}{2024-03-11}{1400}{Jiacheng}{}

\section{Variables \& Attributes}
A \textit{Variable} is a place holder (a named memory location) for a value at run-time. Variables have several attributes at run-time which includes:
\begin{description}
    \item[name] which provides the means for accessing a variable
    \item[address] (also known as it's l-value) which is what is required when the name of the variable appears in the left side of an assignment 
    \item[value] which is the contents of the memory cell(s) (also known as the r-value of a variable)
    \item[type] which determines the range of values that the variable can store and the operations that are defined for the values
    \item[lifetime] which defines the time during which a variable is bound to a specific memory location (i.e. it's address) 
    \item[scope] which is the range of statement in which the variable is visible / accessible 
\end{description}

\section{Declaration}
In most languages, variables are introduced using a declaration. This can either be done implicitly or explicitly.
\subsection{Explicit Declaration}
An Explicit Declaration is a program statement used for declaring the type of the variable. For example, a variable, \verb|i|, is declared in different languages as follows:
\begin{itemize}
    \item in Pascal \verb|i : integer|
    \item in Java \verb|int i;|
    \item in Fortran \verb|INTEGER :: Count|
\end{itemize}
\subsection{Implicit Declaration}
An implicit declaration is a default mechanism for specifying types of variables through default conventions rather than declaration statements. For example, Fortran has both explicit and implicit declarations:
\begin{description}
    \item[Explicit]\ 
    \begin{verbatim}
        INTEGER :: Count, Total
        REAL :: Average, Sum
        COMPLEX :: c
    \end{verbatim}
    \item[Implicit] The default implicit typing rule is that if the first letter of the name is \verb|I|, \verb|J|, \verb|K|, \verb|L|, \verb|M|, or \verb|N|, then the data type is integer, otherwise it's real.
\end{description}
\subsection{Type Inference}
Another kind of implicit type declaration is type inference. This is popular in \textit{modern, edgy} language such as JavaScript and C\# whereby a variable can be declared with \verb|var| or \verb|let| and set with an initial value. This initial value sets the type of the variable. Python takes this one step further whereby a variable is just defined. That's it, there is no keyword required to say that you're defining a variable. For this to work, an initial value must be provided.\\

Type Inference (a way to declare a type) is different from reference type (a data type, e.g. pointer type)

\section{Binding}
A binding is an association between an entity and an attribute, for example - between a variable and it's type, or value, or memory location; or between a symbol (e.g. \verb|+|) and an operation.\\

Binding time is the time at which a binding takes place, which can be at different times. 

\subsection{Binding Time}
If we take the following Java Statements:
\begin{verbatim}
    int count;
    count = count + 5;
\end{verbatim}
We can then review the attributes of the statements and when they're bound.
\begin{description}
    \item[type] of \verb|count| is at \textit{compile time} (because is a typed language, a variable must be declared before it's used)
    \item[range] of possible values of \verb|count| is bound at \textit{compiler design time} 
    \item[operation] (the meaning) of the operator \verb|+| is bound at \textit{compile time} when the types of its operands have been determined
    \item[value] of \verb|count| is bound at the execution of the statement, i.e. \textit{runtime}
\end{description}

It is also possible for binding to take place at load time or link time.
\begin{description}
    \item[Load time] whereby we are binding a C or C++ \verb|static| variable to a memory location
    \item[Link tim ] whereby we are binding the variables in one module with those in another
\end{description}

\subsection{Type Binding: Static vs Dynamic}
A type binding is static if it occurs before runtime and remains unchanged throughout program execution. For example, declarations (implicit or explicit) always carry the type information, and binding is done at compile time. Languages which conform to this are said to be statically typed and include Java, C, Fortran, Pascal, etc. It is advantageous to use one because they are more efficient and the type errors can be detected by the compiler. However, they are disadvantageous because they're not very flexible for interactive applications.\\

Languages which complete type-binding during execution, or where they can change during execution of the program (specified through an assignment statement) use \textit{dynamic} type binding. Examples of languages which do this include Python, JavaScript and PHP. It is advantageous to use a dynamically typed language as they have greater flexibility (given the possibility to produce generic program units); and allow for rapid prototyping. However they are disadvantageous as they have a higher resource cost (given the dynamic type checking at run-time); and that the type-error detection by the compiler is difficult.


% variables and attributes
% declaration
%     implicit declaration
% Binding
%     type binding static v dynamic
%     static dymanic v strong weak
% block structure of programs
% scope of identifiers
%     visibility rule for duplicated identifers
% static and dynamic scoping
%     static scoping
%     dynamic scoping
%     [do compasiron slide in intro to this sect]
% lifetime of variables
%     lifetime and memory Allocation
%     memory allocation
