\taughtsession{Lecture}{Lexical Analysis - Regular Expressions}{2024-02-05}{1400}{Jiacheng}{}

\section{Programming Language Definition}
The full definition of a programming language is important for two different groups of people: language implementers (those who write compilers); and language users (programmers). The full definition of a programming language will include a number of definitions:
\begin{description}
    \item[Lexical Structures] which concern the forms of its symbols, keywords and identifiers
    \item[Syntax] which define the structure of the components of the language, for example the structures of the programs, statements, expressions, terms
    \item[Semantics] which define the meanings and usage of structures and and requirements that cannot be described by grammar (ie checking type consistency, arithmetic operations) 
\end{description}

\subsection{Language Analysis}
A key process of a language implementation system is to analyze the source code, this is both the lexical and syntax structure. The code analysis system of a language generally consists of two parts: 
\begin{description}
    \item[Lexical analyser] is a low-level component which is mathematically equivalent to a finite automaton which is based on regular grammar
    \item[Syntax Analyser] is a high-level component, also known as a parser, which is mathematically equivalent to a push-down automaton that is based on a context-free grammar.
\end{description}

\section{Lexical Analysis}
A lexical analyser works by reading the source program a single character at a time. It outputs tokens to the next phase of the compiler (the parser). The lexical analyser works to identify substrings of the source program that belong together (lexemes). Lexemes match character patters, which are associated with a lexical category called a token. 

\subsection{Definitions: Alphabet}
An alphabet ($\Sigma$) is a finite non-empty set of symbols, for example:
\begin{itemize}
    \item the set $\Sigma_{ab} = \{a,b\}$ is an alphabet comprising symbols $a$ and $b$.
    \item the set $\Sigma_{az} = \{a,\ldots,z\}$ is the alphabet of lowercase English letters
    \item the set $\Sigma_{asc}$ of all ASCII characters is an alphabet
\end{itemize}
\subsection{Definitions: Strings}
A string or word over an alphabet ($\Sigma$) is a finite concatenation (or juxtaposition) of symbols from $\Sigma$. For example:
\begin{itemize}
    \item $abba$, $aaa$ and $baaaa$ are strings over $\Sigma_{ab}$
    \item $hello$, $abacab$ and $baaaa$ are strings over $\Sigma_{az}$
    \item $h\$(e'lo$, $PjM\#;$ and $baaaa$ are strings over $\Sigma_{asc}$
\end{itemize}
The length of a string, $w$ is the number of symbols it has and is denoted as $|w|$. For example $|abba|=4$.\\

The empty or null string is denoted  $\varepsilon$ and therefore $|\varepsilon| = 0$. \\

The set of all strings over $\Sigma$ is denoted $\Sigma^*$ for example
\[\Sigma^*_{ab} = \{\varepsilon, a, b, aa, ab, ba, bb, aab, \ldots\}\]
For any symbol or string $x$, the notation $x^n$ denotes the string of the concatenation of $n$ copies of $x$:
\[a^4 = aaaa \quad \quad (ab)^4 = abababab\]

\section{Regular Expressions}
A regular expression specify a pattern of string of symbols. A regular expression, $r$, matches (or is matched by) a set of strings if the patterns of the strings are those specified by the regular expression. Regular expressions can be used in a variety of applications where more complex string matching is required.\\

The set of strings matched by a RegEx, $r$, is denoted by $L(r) \subseteq \Sigma^*$ (which translates to: those strings belong to all the strings over the alphabet, $\Sigma$) and is called the language determined or generated by $r$. 

\subsection{Definitions}
\subsubsection{Definition 1}
The set for an empty set or empty language, $\emptyset$ is a regular expression. It matches no strings at all and will not be useful to us.\\

The empty string symbol $\varepsilon$ is a regular expression which matches just the empty string $\varepsilon$.\\

The empty string $\varepsilon$ should not be confused with the empty laguage $\emptyset$. $\emptyset$ is a formal language (e.g. a set of strings) that contains no strings, not even the empty string. The empty string is a string that has the properties:
\begin{itemize}
    \item $|\varepsilon| = $ (it's length is 0)
    \item $\varepsilon + s = s + \varepsilon = $ (the empty string is the identity element of the concatenation operation)
\end{itemize}

\subsubsection{Definition 2}
Each symbol $c \in \Sigma$ in the alphabet $\Sigma$ is a Regular Expression. This RegEx matches the string consisting of just the symbol $c$. For example, for the alphabet $\Sigma = \{a, b\}$ we have:
\begin{itemize}
    \item RegEx $a$ matches the string $a$
    \item RegEx $b$ matches the string $b$
    \item Both symbols $a$ and $b$ are RegExs
\end{itemize}

\subsubsection{Definition 3}
If $r$ and $s$ are regular expressions, then $r | s$ (sometimes written as $r+s$, which is read as ``$r$ or $s$'') is a RegEx. For example:
\begin{itemize}
    \item RegEx $a|b$ matches the string $a$ or $b$
    \item $a|\varepsilon$ matches the strings $a$ or $\varepsilon$
\end{itemize}

\subsubsection{Definition 4}
If $r$ and $s$ are regular expressions, then concatenation $rs$ (read ``$r$ followed by $s$'') is a RegEx. This matches any concatenation of two strings where the first string matchces $r$ and the second matches $s$. For example: 
\begin{itemize}
    \item RegEx $ab$ matches the string $ab$
    \item RegEx $abba$ matches the string $abba$
\end{itemize}
As with arithmetic expressions, parentheses can be used in RegExs to make the meaning of a RegEx clearer. For example $(a|b)a$ matches the strings $aa$ and $ba$. 

\subsubsection{Definition 5}
The RegEX $r^*$ (read ``zero or more instances of $r$'') is a Regular Expression. This matches all finite (possibly empty) concatenations of string matched by $r$.

\subsubsection{Definition 6}
The RegEx $rr^*$ read as ``one or more instances of strings matched by $r$'' can also be written as $r^+$. 

\subsection{Examples}
\begin{itemize}
    \item RegEx $a^*$ matches the strings $\varepsilon$, $a$, $aa$, $aaa$, \ldots
    \item RegEx $(ab)^*$ matches the strings $\varepsilon$, $ab$, $abab$, \ldots
    \item RegEx $(a|bb)^*$ matches the strings $\varepsilon$, $a$, $bb$, $abb$, $baa$, $abba$, \ldots
    \item RegEx $(a|b)^*aab$ matches any string ending with $aab$
    \item RegEx $(a|b)^*baa(a|b)$ matches any string containing the substring $baa$
\end{itemize}

\subsection{Precedence}
As with all `operators', the different symbols in Regular Expressions have different precedences, they are shown below in the order highest \rightarrow lowest.
\begin{enumerate}
    \item $()$
    \item $^*$ or $^+$
    \item concatenation
    \item $|$
\end{enumerate}

\subsection{Using Regular Expressions for Lexical Analysis}
Regular Expressions provide us with a way to describe the patterns of a programming language. This is useful as it can be used as a `shorthand' rather than saying ``a number is any combination of 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9''.\\

We assume that the alphabet used here is $\Sigma_{asc}$ since the source program takes the form of an ASCII (text) file. Some example patterns for a typical programming language are shown below:
\begin{itemize}
    \item $if$ for token \verb|IF|
    \item $;$ for token \verb|SEMICOLON|
    \item $(0|1|2|3|4|5|6|7|8|9)^+$ for a token \verb|NUMBER|
    \item $(a|\ldots|z|A|\ldots|Z)(\_|a|\ldots|z|A|\ldots|Z|0|\ldots|9)^*$ for a token \verb|IDENT|
\end{itemize}

\subsection{Regular Definitions}
We can give RegExs names which make them easier to read and write; and the names can be used to define other regular expressions. For Example:
\begin{itemize}
    \item $letter = A|B|\ldots|Z|a|b|\ldots|z$
    \item $digit = 0|1|\ldots|9$
    \item $ident = letter(\_|letter|digit)^*$
\end{itemize}

\section{Definition of Lexical Languages}
Languages, $L$, are sets of strings (written in the form of a set $\{\ldots\}$), chosen from the strings over some alphabet $\Sigma$. This can formally be defined as:
\begin{center}
A language $L$ over an alphabet $\Sigma$ is a subset of $\Sigma^*$ (i.e., $L \subseteq \Sigma^*$).
\end{center}
For example:
\begin{itemize}
    \item $\{\varepsilon, aab, bb\}$ is a language over $\Sigma_{ab}$
    \item The set of all Java programs is a language over $\Sigma_{asc}$; and so is the set of all C++ programs
    \item $\emptyset$ is the empty language (over any alphabet) with no strings
    \item $\{\varepsilon\}$ is a language (over any alphabet) containing just the empty string
    \item $\{a^nb | b \geq0\}$ is a language over $\Sigma_{ab}$ comprising all strings of 0 or more $a$ followed by a single $b$
    \item $\Sigma^*$ is a language over $\Sigma$ for any alphabet $\Sigma$
\end{itemize}

We denote the language of RegEx's in the form $L(RE)$. For example:
\begin{itemize}
    \item $L(a^*) = \{\varepsilon, a, aa, aaa, \ldots \}$
    \item $L(ba^*) = \{b, ba, baa, baaa, \ldots\}$
    \item $L(a|b) = L(a) \cup L(b)$
\end{itemize}

\subsection{Decidability of Languages}
Given a language $L$ over some alphabet $\Sigma$, it is important to be able to write an algorithm that takes any string ( $w \in \Sigma^*$ ) as an input and:
\begin{itemize}
    \item outputs `Yes' if $w \in L$ and
    \item outputs `No' if $w \notin L$
\end{itemize}
An algorithm that does this is called a decision procedure for $L$. 

\subsection{Regular Expressions and Decision Procedures}
There are two different algorithms which can be used to write a decision procedure for language:
\begin{itemize}
    \item Deterministic Finite Automation (DFA)
    \item Nondeterministic Finite Automation (NFA)
\end{itemize}
Languages that can be denoted by a RegEx, and can have a DFA / NFA as a decision procedure, are known as \textit{regular languages}. This means that  if we can describe a program's language using RegExs and the RegExs have a DFA / NFA then, we can write the lexical analyser using a DFA (or NFA). 