\taughtsession{Lecture}{Introduction to Functional Programming}{2024-01-22}{1200}{Matthew}{}

\section{Introduction}
\textit{Functional Programming} is a different programming paradigm. There are all sorts of different ways we can classify a programming language, paradigm being one of them. More details on this in another module.

\subsection{Imperative vs Functional Programming}
Before we go too deep into Functional Programming, we will first look at the structure of Imperative Programming.\\

Imperative Programming is a paradigm where the execution of the program consists of executions of \textit{statements}, which each impact the program's \textit{state}. \textit{Side Effects} can be caused by the statements; these are things that the program does where it cannot guarantee the outcome - for example get the current temperature, ask the user to enter a number or getting the system time.\\

Pure Functional Programming does not have a state, does not have statements and does not have side effects. However - side effects are a ``necessary evil'' so they get brought back in isolated from the main program. Once side effects are introduced, our functional programming becomes impure.

\section{Functional Programming}
In Functional Programming, there are three key terms - expression, evaluation and value. An expression is some text which has a value, for example \verb|2 * 3 + 1|; a value is the thing which the expression has, for example \verb|7|; and evaluation is the process used to obtain a value from an expression.\\

We will start our FunProg journey looking at Mathematical Functions, which we can think of as a box which maps argument values to a result value. A Haskell program is mainly made up of Function definitions, for example
\begin{verbatim}
    square :: Int -> Int
    square n = n * n
\end{verbatim}
The first line above starts with the function name, then lists the parameters (a single \verb|Int|), then finally the result type. The second line is the actual function, starting with the name, then the names assigned to the parameters, then the value which gets returned. The double colon (\verb|::|) is read as `is type of'. \\

\section{Data Types: A Brief Introduction}
Haskell includes a number of basic data types which we can make use of.
\subsection{Boolean}
The \verb|Bool| data type has the values \verb|True| and \verb|False|. As well as having the boolean operators \verb|&&| (and); \verb+||+ (or); and \verb|not| (not). These can be seen implemented in the following function which implements the \textit{exclusive or} operator (which gives True when exactly one of its arguments is True):
\begin{verbatim}
    exOr :: Bool -> Bool -> Bool
    exOr x y = (x || y) && not (x && y)
\end{verbatim}

\subsection{Int \& Float}
Haskell includes a number of different numerical data types - we'll start of using the \verb|Int| and \verb|Float| types. \verb|Int| is a fixed-space integer data type; and \verb|Float| is a floating point data type. Operators for these data types include:
\begin{itemize}
    \item arithmetic operators: \verb|+|, \verb|-| and \verb|*|
    \item The \verb|Float| data type includes floating point division \verb|/|
    \item The \verb|Int| has integer division and remainder functions \verb|div| and \verb|mod|
    \item relation operators: \verb|==|, \verb|/=| (not equals), \verb|<|, \verb|>|, \verb|<=| and \verb|>=|
\end{itemize}
The operators use the standard precedence rules (as experienced in other languages). 

\section{Conditional Expressions}
Haskell includes a conditional expression which takes the form:
\begin{verbatim}
    if condition then m else n
\end{verbatim}
where \verb|condition| is a boolean expression and \verb|m| \& \verb|n| are expressions of the same type Where \verb|condition| is true - the expression evaluates to \verb|m|; and where \verb|condition| is false - the expression evaluates to \verb|n|.\\

In the next lecture, we'll see an alternative to conditional expressions.