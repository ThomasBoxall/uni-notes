\taughtsession{Lecture}{Software Defined Networking}{2025-12-08}{11:00}{Asim}

Software Defined Networking (SDN) is an alternative paradigm of networking which separates the network control from the data forwarding by using software. This allows for centralised, programmable management of the entire network. 

\section{Planes}
No, not the things flying in the sky...

\subsection{Data Plane}
The data plane transmits and receives data packets. It focuses on forwarding data packets based on routing destinations; and uses protocols such as TCP/IP and UDP. 

\subsection{Control Plane}
The control plane is concerned with routing of data, naming of devices, declaring policies and performing security checks. It is responsible with managing and controlling the network. The control plane uses protocols such as OSPF, BGP and MPLS.

\subsection{Management Plane}
The management plane configures and monitors network devices. It uses protocols such as SSH, Telnet and SNMP.

\section{Server Virtualisation}
Traditionally, servers were used in a single server per application paradigm. Taking into account testing, development, pre-production, production, and disaster recovery - a single application may require 3 to 5 servers. However the traditional workload of a single one of these servers would be very low which is obviously bad. 

Server Virtualisation is a way to consolidate servers by allowing a single physical host to run multiple workloads. A `virtual server' is a software implementation that executes programs like a real server. Multiple virtual servers can work simultaneously on one single physical host server server. Therefore instead of operating many servers at low utilisation, virtualisation combines the processing power onto fewer servers that operate at a higher total utilisation. 

Virtualisation improves scalability, reduces downtime and enables faster deployments. It can also speed up disaster recovery efforts because virtual servers can restart applications much faster than physical servers. With virtualisation, entire systems can be moved from one physical host to another in just a few seconds - to optimise workloads or to perform maintenance without causing downtime.

Some virtualisation solutions also have built-in resiliency features such as high availability, load balancing and failover capabilities. Virtualisation has become commonplace in large data centres; however is less common (as of 8 years ago when these slides were written) in smaller data centres. 

The application running directly on a physical host server is called a Hypervisor, specifically a type 1 hypervisor. 

Server virtualisation masks server resources (both hardware and software) from users. Virtual server hosts can host multiple VM servers. 

However, virtual servers introduce the need for virtual LANs to be configured. The physical server and the VM need to use the same switch port. The network needs to be reconfigured whenever the VM migrates. 

\section{Dynamic Configuration of Network Resources}
Especially when using Server Virtualisaiton, but also more generally in modern networks - there is a need for dynamic configuration of network resources. 

This is needed for management of traffic amongst virtual servers for the following:
\begin{itemize}
    \item To maintain consistent database images
    \item Invoke security functions such as access control
    \item Server-to-server traffic changes with location and time
\end{itemize}

This is also needed for performance management of enterprise networks:
\begin{itemize}
    \item Users access enterprise resources through mobile devices
    \item Load changes dynamically with location and time
    \item Manual configuration of network servers take long time due to different vendors and different interfaces of devices
    \item Managers need to configure equipment from different vendors separately on per session per application basis
\end{itemize}

\subsection{Traditional Network Configuration}
Network managers must be able to respond to changing resources, quality of service needs, and security requirements by providing differentiated QoS levels and security levels for individual traffic flows. The network manager must configure each vendor's equipment separately and adjust security parameters on a per-session, per-application basis. 

In a large enterprise network, every time a new VM is brought up, it can take hours or even days for network managers to do the necessary reconfiguration. 

\section{SDN Architecture}
The architecture of SDN centres around a central controller who performs all complex functions, including routing, naming, policy declaration and security checks. This controller is the SDN control plane and consists of one or more SDN servers. The SDN controller defines the data flow that occurs in the SDN data plane. 

Each flow through the network has to first get permission from the controller, which verifies the communication is permissible by the network policy. If the controller allows a flow, it computes a route for the flow to take and adds an entry for that flow in each of the switches along the path. With all complex functions handled by the controller, the switches are able to solely manage the flow tables.

Communication between the controller and the switches uses a standardised protocol and API. This is most commonly in line with the OpenFlow specification. 

\subsection{OpenFlow}
OpenFlow is the protocol used for communication between the SDN Controller and switches. This communication takes place over SSL.

Each OpenFlow switch will connect to other OpenFlow switches and sometimes to end-user devices. Within each switch, there are a series of tables which are typically implemented in hardware or firmware, that are used to manage the flows of the packets through the switch. The OpenFlow specification defines a number of types of tables in the logical switch architecture:
\begin{description}
    \item[Flow Table] matches incoming packets to a particular flow and specifies what functions are to be performed on the packets. There may be multiple flow tables that operate in a pipeline fashion. A flow table may direct a flow to a group table which may trigger a variety of actions that affect one or more flows.
    \item[Meter Table] can trigger a variety of performance related actions on a flow.
\end{description}

A \textit{flow} in this context refers to a sequence of packets traversing a network that share a set of header field values (source IP, destination IP, VLAN identifier, etc).

An OpenFlow switch encapsulates and forwards a flow's first packet to a SDN controller. The switch forwards incoming packets out of the appropriate port based on the flow table. The switch can drop packets on a particular flow, either temporarily or permanently as dictated by the controller. 

There are three different communication classes defined in the OpenFlow protocol. \textit{Controller to Switch} is used by the controller to program, configure and retrieve information from the switch. \textit{Asynchronous (switch to controller)} is initiated by the OpenFlow switch to and sends to the controller to report packet arrivals, state changes, errors, etc. \textit{Symmetric (switch to controller) and Controller to switch} allows either to side to send message without solicitation; for example hello or echo messages to identify if the control channel is still alive and available. 

\subsection{Domains}
It is possible for multiple SDNs to exist in proximity to one another. The existence of multiple domains creates a requirements for individual controllers to communicate with each other via a standardised protocol and to exchange routing information. A protocol, SDNi, is being developed for interfacing between SDN domain controllers. It's functionality includes the following:
\begin{itemize}
    \item coordinate flow setup originated by applications containing information such as path requirement, QoS and SLA
    \item Exchange reachability informaiton to facilitate inter-SDN routing; allowing a single flow to traveerse multiple SDNs and have each controller select the most appropriate path when multiple such paths are available
\end{itemize}

As of when these slides were written, SDNi is discussed as something coming in the future. It doesn't appear SDNi has gone anywhere, with the IETF noting the draft as `no longer active'.

\subsection{Scope and Scale}
Typically a physically centralised control plane is adapted for SDN. It can be implemented in a single server but this is a single point of failure and a potential bottleneck. There may also be reliability or scalability issues.

The alternative to this is a logically centralised distributed control plane. This comprises of physically distributed elements that interface to each other through east \& west bound interfaces. The data plane and the applications only see a single logical controller.

\section{SDN Flows}
As we already know, the OpenFlow protocol uses tables to route packet sequences (flows) from the sender to the receiver. When a flow arrives to a OpenFlow switch, a table lookup is performed. If no matching route is found, a request to the controller is made; the reply from the controller is handled in one of three different modes - Proactive, Reactive or Hybrid.

\subsection{Reactive Mode}
In reactive mode, the controller is queried when packets arrive and there is no entry or an expired timer has expired for the required destination. The controller creates and installs a rule in the corresponding switch if necessary. Importantly, the rule is only installed on switches which will be implicated in the forwarding of this flow. 

\begin{example}{Reactive Mode}
In this example Host 1 (H1) sends a packet to Host 2 (H2) which is split into two fragments: P1.F1 and P1.F2. H1 also sends a packet to Host 3 (H3) which is split into three fragments: P2.F1, P2.F2 and P2.F3. 

The network in this example is made up of the following: H1 connects to Switch 1 (S1) which is connected to Switch 4 (S4). S4 is connected to both Switch 2 (S2) (connected to H2) and Switch 3 (S3) (connected to H3). All Switches are connected to the SDN Controller (C).

The reactive data flow works as follows:
\begin{itemize}
    \item H1 (P1.F1) $\rightarrow$ S1 (Req) $\rightarrow$ C (Entry) $\rightarrow$ (S1, S4, S2)
    \item S1 (P1.F1) $\rightarrow$ S4 (P1.F1) $\rightarrow$ S2 (P1.F1) $\rightarrow$ H2
    \item H1 (P1.F2) $\rightarrow$ S1 (P1.F2) $\rightarrow$ S4 (P1.F2) $\rightarrow$ S2 (P1.F2) $\rightarrow$ H2
    \item H1 (P2.F1) $\rightarrow$ S1 (Req) $\rightarrow$ C (Entry) $\rightarrow$ (S1, S4, S3)
    \item S1 (P2.F1) $\rightarrow$ S4 (P2.F1) $\rightarrow$ S3 (P2.F1) $\rightarrow$ H3
    \item H1 (P2.F2) $\rightarrow$ S1 (P2.F2) $\rightarrow$ S4 (P2.F2) $\rightarrow$ S3 (P2.F2) $\rightarrow$ H3
    \item H1 (P2.F3) $\rightarrow$ S1 (P2.F3) $\rightarrow$ S4 (P2.F3) $\rightarrow$ S3 (P2.F3) $\rightarrow$ H3
\end{itemize}
\end{example}

\subsection{Proactive Mode}
In proactive mode, the controller populates flow tables for all possible traffic matches. These are static entries and they are installed ahead of time of the transmission. Following this - no request is sent to the controller since all incoming flows will find a matching entry. This is advantageous (over reactive mode) as all packets are forwarded at line rate so there is no delay; however it is at a disadvantage because the flow table when implemented in associative memory is very expensive for large tables. 

\begin{example}{Proactive Mode}
In this example Host 1 (H1) sends a packet to Host 2 (H2) which is split into two fragments: P1.F1 and P1.F2. H1 also sends a packet to Host 3 (H3) which is split into three fragments: P2.F1, P2.F2 and P2.F3. 

The network in this example is made up of the following: H1 connects to Switch 1 (S1) which is connected to Switch 4 (S4). S4 is connected to both Switch 2 (S2) (connected to H2) and Switch 3 (S3) (connected to H3). All Switches are connected to the SDN Controller (C).

The reactive data flow works as follows:
\begin{itemize}
    \item H1 (P1.F1) $\rightarrow$ S1 (Req) $\rightarrow$ C (Table) $\rightarrow$ (S1, S2, S3, S4)
    \item S1 (P1.F1) $\rightarrow$ S4 (P1.F1) $\rightarrow$ S2 (P1.F1) $\rightarrow$ H2
    \item H1 (P1.F2) $\rightarrow$ S1 (P1.F2) $\rightarrow$ S4 (P1.F2) $\rightarrow$ S2 (P1.F2) $\rightarrow$ H2
    \item H1 (P2.F1) $\rightarrow$ S1 (P2.F1) $\rightarrow$ S4 (P2.F1) $\rightarrow$ S3 (P2.F1) $\rightarrow$ H3 
    \item H1 (P2.F2) $\rightarrow$ S1 (P2.F2) $\rightarrow$ S4 (P2.F2) $\rightarrow$ S3 (P2.F2) $\rightarrow$ H3 
    \item H1 (P2.F3) $\rightarrow$ S1 (P2.F3) $\rightarrow$ S4 (P2.F3) $\rightarrow$ S3 (P2.F3) $\rightarrow$ H3 

\end{itemize}
\end{example}