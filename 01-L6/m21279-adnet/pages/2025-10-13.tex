\taughtsession{Lecture}{Security}{2025-10-13}{11:00}{Asim}

\section{Security Requirements}
Within \textit{Network Security} there are three important requirements. The three requirements work together to ensure that network transmissions are of a good security standard.
\begin{define}
\item[Confidentiality] Ensuring that only authorised parties can read the message; therefore restricting unauthorised third parties from accessing it
\item[Integrity] Ensuring that the transmitted message is exactly the same as the received message and that only authorised parties can modify, delete, or reply to the message
\item[Availability] Ensuring the message is available on demand to authorised parties only
\end{define}

\section{Attack Types}
There are two main types of attack used.

\begin{define}
\item[Passive Attacks] Adversaries analyse the traffic or read message content
\item[Active Attacks] Adversaries modify the message content, deny the service to a request, replay to a message and masquerade (pretend to be a different entity) 
\end{define}

We can attempt to overcome the threats using cryptography to encrypt the message on the transmitter's side, and then ensure that only the designated recipient can decode the message.

The message we want to encrypt, known as the \textit{plaintext}, is transformed by a function that is parametrised by a \textit{key}. The output of the encryption process, known as the \textit{ciphertext}, is then transmitted. If this ciphertext is intercepted by the adversary, they are unable to directly interpret it as they do not know what the key used in the encryption process was. However, it may be possible for the adversary to crack the cipher depending on the encryption method used.

There is a standard notation for the plaintext, ciphertext and keys. $C=E_K(P)$ is used to represent the encryption, $E$ of the plaintext, $P$ using the key, $K$ which results in the ciphertext, $C$. The decryption is defined as $P=D_K(C)$ where the plaintext, $P$, is the result of applying the decryption, $D$, with the key, $K$, on the ciphertext, $C$. 

\section{Encryption Techniques}
There are a number of Encryption Techniques used commonly.

\subsection{Substitution cipher}
In a \textit{substitution cipher}, each letter or group of letters is directly replaced by another letter or group of letters which disguises it. 

A well-known example of this is the Ceaser Cipher. 

\begin{example}{Substitution Cipher}
If we take the following substitution:

\begin{figure}[H]
\centering
\begin{BVerbatim}
Plaintext:     a b c d e f h g i j k l m n o p q r s t u v w x y z
Ciphertext:    Q W E R T Y U I O P A S D F G H J K L Z X C V B N M
\end{BVerbatim}
\caption{Substitution Matrix}
\end{figure}

We can see how we convert from plaintext to ciphertext.

For example, taking the plaintext \textit{attack} - we get the ciphertext \textit{QZZQEA}; or taking the plaintext \textit{london}, we get the Ciphertext \textit{SGFRGF}. 
\end{example}

Using a standard alphabet with 26 characters, assuming we only use lowercase letters, then there are $4 \times 10^{26}$ possible combinations. Which on a computer with one million CPU cores - can take up to 10,000 years to crack.

\subsection{Transposition Cipher}
In a \textit{transposition cipher}, we take a key and use this key to design a grid which we populate with our plaintext, working row-by-row. We then read the ciphertext from the grid reading column-by-column in alphabetical order of the key's letter.

\begin{example}{Transposition Cipher}
If we take the plaintext \textit{pleasetransferonemilliondollarstomyswissbankaccountsixtwotwo} and the key \textit{MEGABUCK}. 

We start by writing out the key at the top of the grid, and assigning a number to each column. In our case, the numbers are assigned in ascending order of the alphabet.

\begin{figure}[H]
\centering
\begin{BVerbatim}
M E G A B U C K
7 4 5 1 2 8 3 6
\end{BVerbatim}
\caption{Transposition Cipher Matrix with Key and Number shown}
\end{figure}

We can then take our plaintext and write that into the matrix working down the rows. We pad the end of the string to fill out the last row entirely, in our case we're using the start characters of the alphabet.

\begin{figure}[H]
\centering
\begin{BVerbatim}
M E G A B U C K
7 4 5 1 2 8 3 6
p l e a s e t r
a n s f e r o n
e m i l l i o n
d o l l a r s t
o m y s w i s s
b a n k a c c o
u n t s i x t w
o t w o a b c d
\end{BVerbatim}
\caption{Transposition Cipher Matrix with plaintext added}
\end{figure}

To get the ciphertext out of the matrix, we read from the matrix vertically in order of the column numbers: \textit{afllsksoselawaiatoossctclnmomantesilyntwrnntsowdpaedobuoeriricxb}. 

To decode the message, a similar process is followed: setup the matrix by writing the key, and the column numbers; then write in the ciphertext in columns based on the order of the numbers; then read rows to obtain the plaintext.
\end{example}

\section{Symmetric Encryption}
Symmetric Encryption is an encryption method in which the sender and receiver both use the same key to encode and decode the message. This is where it's alternative name, \textit{shared key encryption} comes from. 

Symmetric Encryption works through taking the plaintext input which is then encrypted using the key, $K$. The encryption algorithm will perform various substitutions or transformations on the plaintext, which will be key-dependent. This means that the same plaintext, with two different keys and the same encryption algorithm will produce two different ciphertexts. The ciphertext is then transmitted to the receiver. The receiver then decrypts the message using that pre-shared-key, $K$. The decryption algorithm is effectively the encryption algorithm run in reverse. This gives them the plaintext. 

To denote a shared public key between $A$ and $B$, we may see the key notated as $K_{AB+}$.

We can see an example of a Symmetric Encryption in the DES encryption method.

\subsection{DES}
The \textit{Data Encryption Standard}, or DES, is a symmetric-key encryption algorithm which was developed in the 1970s and has been hugely influential in modern-day cryptography.

The plaintext input for DES is always 64-bits in length, and the key is always 56-bits. If the total plaintext needing to be encrypted using DES is longer than 64-bits then it gets chunked into 64-bit chunks so then the DES algorithm can process its 64-bit blocks. 

The DES algorithm works by taking the 56-bit key and generating 16 sub-keys from it. These 16 sub-keys are each used for their own round of encryption, therefore the DES algorithm encrypts the plaintext 16 times through a sequence iterating on the output of the previous as the input to the next. The keys are used in reverse order - meaning $K_{16}$ is used on the first iteration, $K_{15}$ on the second, and so on until $K_1$ is used on the final iteration. 

DES works through the 16 rounds of encryption following a modified \textit{Feistel Network} structure. This works by taking the plaintext and splitting it into two substrings of equal length. One half of the key is passed to the F-Function (Feistel Function) which performs Expansion, Key-Mixing, Substitution and Permutation operations on the input and that round's key. The output from the F-Function then gets XOR'd with the other half of the input string. The next round is then prepared by feeding the output from the XOR operation into the next F-Function, and the input to the current round's F-Function to the next rounds XOR. There are 16 rounds of this in total. The final ciphertext is created by concatenating the output of the final XOR with the output of the penultimate XOR operation (which fed into the F-Function, the output from which fed into the input to the final XOR operation). 

\begin{extlink}
There is a diagram explaining the Feistel Network in the slides on Moodle.
\end{extlink}


\subsection{3DES}
The \textit{Triple Data Encryption Standard}, or 3DES, is a symmetric-key encryption algorithm which apples the DES algorithm three times to each block. 

3DES works with three keys, $K_1$, $K_2$, and $K_3$. It will use $K_1$ on the first round of DES encrypting the data. Then the second round of DES will decrypt the data using $K_2$. The third and final round of DES will encrypt the data using $K_3$. The middle decryption doesn't return the data to the plaintext state, as $K_1 \neq K_2$. 

Decryption follows the same encryption process but in reverse: decrypting with $K_3$, encrypting with $K_2$ before decrypting with $K_1$. 

\subsection{AES}
The \textit{Advanced Encryption Standard}, or AES, is a symmetric-key encryption algorithm which was designed to replace DES.

AES supports three different key lengths: 128-bit, 192-bit and 256-bit. Similarly to how DES works on 64-bits of data at a time, AES works on 128-bit blocks of data and will perform $n$ rounds depending on the different key-length used. 128-bit keys get 10 rounds, 192-bit keys get 12 rounds and 256-bit keys get 14 rounds. 

\section{Asymmetric Encryption}
Asymmetric Encryption is an encryption method where the sender and receiver both use different keys to encode and decode the message. This is where it's alternative name, \textit{Public Key Encryption} comes form.

The sender encrypts the plaintext with the receivers public key to produce the ciphertext. The ciphertext is then transmitted over the network to the receiver. The receiver uses their private key to decrypt the message thus producing the plaintext. 

The public key of the receiver is made available to anyone who wants to send the receiver a message. The public key of anyone is restricted to them and them alone - leaking of a public key would mean that an adversary could decode the message. Due to the receivers public keys being required to be able to send the receiver a message - senders will have as many public keys as the number of people they send messages to.

A major flaw with this model is that an adversary could intercept the public-key encoded message and stop it from reaching the receiver. Whilst they couldn't read that message, they could spoof that message by sending their own payload encoded with the receivers public key. The receiver would receive this and decode it. 

They keys may be notated as follows:
\begin{itemize}
    \item Senders public key: $K_{A+}$
    \item Senders private key: $K_{A-}$
    \item Receivers public key: $K_{B+}$
    \item Receivers private Key: $K_{B-}$
\end{itemize}

We can see an example of the Asymmetric Encryption in the RSA algorithm. 

\subsection{RSA}
The \textit{Rivest-Shamir-Adlerman} cryptosystem, or RSA, is a public-key cryptosystem which was developed in 1973 at GHCQ. 

RSA works through taking two large prime numbers where their product is used to form the public key (along with other values used). The original prime numbers are kept secret. Then anyone can use the public key to encrypt the message. The message is transformed using mathematical operations which involve the public key. On the receiving end - only the corresponding private key can decrypt the message. The decryption process involves the original prime factors to reverse the encryption.

The RSA process can be formalised below:
\begin{enumerate}
    \item Chose two large primes, $p$ and $q$.
    \item $n=p\times q$ and $z=(q-1) \times (q-1)$
    \item Choose a number relatively prime to $z$ and call it $d$
    \item Find $e$ such that $e \times d = 1 \mod z$
    \item To encrypt a message, $P$, compute $C=P^e(\mod n)$
    \item To decrypt the ciphertext, $C$, compute $P=C^d(\mod n)$
    \item The public key is $(e, n)$ and the private key is $(d, n)$.
\end{enumerate}

\begin{example}{RSA}
We can see the above steps with real numbers substituted in below:
\begin{enumerate}
    \item Let $p=3$ and $q=11$
    \item Therefore $n=33$ and $z=20$
    \item Let $d=7$
    \item We can calculate $e$ using  $e \times 7 = \mod 20$ which sets $e=3$
    \item We can encrypt our message, for example $19$ by performing $C = 19^3(\mod 33)=28$
    \item We can decrypt the ciphertext, in this example $28$ by performing $P=28^7(\mod 33)=19$
    \item This means we know that the public key was $(3,33)$ and the private key was $(7,33)$.
\end{enumerate}
\end{example}

\begin{extlink}
There is a more fleshed-out example of the RSA process for the string ``SUZANNE'' in the slides on Moodle.
\end{extlink}

\section{Ensuring Confidentiality}
As we have already seen - we need to ensure confidentiality within the transmission to ensure that adversaries cannot intercept and access the message.

\subsection{Within a Symmetric Encryption Network}
As both the sender and the receiver share the same private key ($K_{AB}$), the adversary cannot decode the message as they do not have the key. 

The sender encodes the plain text message into a cipher text $C=D_{K_{AB}}(M)$. Only the receiver, who has the key, is able to decrypt it using $P=D_{K_{AB}}(E_{K_{AB}}(M))$

\subsection{Within an Asymmetric Encryption Network}
The adversary is not able to read the transmitted message. 

Both the sender (A) and receiver (B) compute their own private keys ($K_{A-}$, $K_{B-}$) and public keys ($K_{A+}$, $K_{B+}$). The public keys are advertised on the network.

When a transmission occurs - the sender will use the receivers public key to encrypt the message $C=E_{K_{B-}}(P)$. Therefore only the receiver can decode the message using their private key $P=D_{K_{B+}}(C)$, alternatively shown as $P=D_{K_{B+}}(E_{K_{B-}}(P))$. 

\section{Ensuring Integrity}
We have to ensure integrity of our transmitted messages to ensure that the user who says they transmitted the message are actually the person who transmitted the message. This is for in the event that an adversary intercepts and replaces a message transmitted from Sender to Receiver with a message sent from adversary to Receiver pretending it was from the original sender.

\subsection{Digital Signatures}
The use of a \textit{Digital Signature}, or \textit{Reverse Public Key} is a method of ensuring integrity which removes confidentiality from the encryption process. 

Digital Signatures work by the sender encrypting the message using their private key ($K_{A-})$. The receiver then uses the public key of the sender ($K_{A+}$) to decrypt the received message. This means that then the sender and only the sender can encrypt messages, however anyone on the network who has the senders public key is also able to decrypt the message. This therefore means that any adversaries on the network cannot change the contents of the message.

\subsection{Message Digests}
The \textit{Message Digests} method works through producing a short fingerprint of the message, which is a hash of the message, represented as $H(M)$. The hash function works by encrypting a small block fo the message which is the function of the document. The hash of two different messages will always be different and it is impossible to find $M$ from $H(M)$.

The has is encrypted with the senders private key, while the message itself is encrypted with the receivers public key. The hash therefore serves as a signature verifying the origin of the document, content and sequencing. This works because the adversary does not have the senders private key, so they cannot spoof a hash value. 

\section{Authentication}
Authentication verifies that the messages came from an authentic source. Authentication can be achieved by conventional techniques:
\begin{itemize}
    \item Private Key for authentication source
    \item Error detection and sequencing for message alteration 
    \item Timestamp for messages delayed 
\end{itemize}

Authentication is important because it shows that the message has come from a trusted, authentic source. Adversaries may record the messages and then re-play messages at a later time which they have captured. This would look like it's coming form the right person as they are correctly encrypted using the correct keys - however in reality it's a retransmission. This type of attack is called a \textit{Play-Back Attack}

\subsection{Symmetric Key Authentication}
Authentication can be introduced to the symmetric-key encryption model through the following steps:
\begin{enumerate}
    \item Sender sends their ID (i.e. a password) to receiver
    \item Receiver responds with a one-time random number (called a \textit{nonce}). The adversary as well as the sender could pick up the nonce $R_B$. 
    \item The sender encrypts using the private shared key, $K_{AB}$ and sends this back to the receiver. The adversary may also pick this up, however they cannot decrypt because they don't have the key. The receiver decrypts the message and now knows they are talking to the sender.
    \item The sender sends their own Nonce number, $R_A$ to the receiver. The receiver encrypts this and sends it back to the sender. Only the sender can decrypt this, again because shared keys, and they now know they are talking to the sender. 
\end{enumerate}

This prevents playback because of the session established between the sender and the receiver. If the adversary tried to re-send a message later in time - the session would most likely have expired and so the receiver of that message would know to discard because it's not valid any more. 

\subsection{Public Key Authentication}
In what can only be described as \textit{the pinnacle of this lecture}, we will now see how Confidentiality, Integrity and Availability are maintained while transmitting secure messages across a communications network.

\textit{Public Key Authentication} involves three parties: the sender, the receiver and the PKI (\textit{Public Key Infrastructure}). The PKI is a centralised repository for public keys for devices on a given network. The Sender and Receiver's public keys are submitted to the PKI through an authentication-heavy trust-laden process (which we don't need to know about in this module). 

The Public Key Authentication process is numbered below (now featuring A and B rather than sender and receiver):
\begin{enumerate}
    \item A sends a request for B's public key to the PKI
    \item PKI returns B's public key to the A ($K_{B+}$)
    \item Encrypted with the B's public key, A sends B their identification and a Nonce: $K_{B+}(A, R_A)$
    \item B then requests A's public key from the PKI
    \item The PKI sends B A's public key ($K_{A+}$)
    \item B now sends A their Nonce, A's Nonce, and a shared key to use for this session - all of which gets encrypted with A's public key: $K_{A+}(R_B, R_A, K_S)$
    \item A receives this and decodes it using their private key, and then returns just B's nonce encrypted with the shared session key to B: $K_S(R_B)$
\end{enumerate}

A authenticates B when they receive $R_A$ in step 6. This proves it's a fresh message, not playback. B authenticates A when they receive $R_B$ in step 7. 

The adversary can fabricate a message at step 3, but as soon as $A$ receives the wrong $R_A$ back in step 6 - the session will be terminated. 

The session key will be used as a private key for the duration of the communication; therefore achieving what we know to be the most secure form of communication. The short-lived session keys prevent playback because if a adversary attempts to play back a message, it's session will have expired so the message is discarded.


\begin{todo}
Add diagrams for generic model of secure network as this will be needed in the exam.
\end{todo}