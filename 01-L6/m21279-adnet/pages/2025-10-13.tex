\taughtsession{Lecture}{Security}{2025-10-13}{11:00}{Asim}

\section{Security Requirements}
Within \textit{Network Security} there are three important requirements. The three requirements work together to ensure that network transmissions are of a good security standard.
\begin{define}
\item[Confidentiality] Ensuring that only authorised parties can read the message; therefore restricting unauthorised third parties from accessing it
\item[Integrity] Ensuring that the transmitted message is exactly the same as the received message and that only authorised parties can modify, delete, or reply to the message
\item[Availability] Ensuring the message is available on demand to authorised parties only
\end{define}

\section{Attack Types}
There are two main types of attack used.

\begin{define}
\item[Passive Attacks] Threat Actors analyse the traffic or read message content
\item[Active Attacks] Threat Actors modify the message content, deny the service to a request, replay to a message and masquerade (pretend to be a different entity) 
\end{define}

We can attempt to overcome the threats using cryptography to encrypt the message on the transmitter's side, and then ensure that only the designated recipient can decode the message.

The message we want to encrypt, known as the \textit{plaintext}, is transformed by a function that is parametrised by a \textit{key}. The output of the encryption process, known as the \textit{ciphertext}, is then transmitted. If this ciphertext is intercepted by the threat actor, they are unable to directly interpret it as they do not know what the key used in the encryption process was. However, it may be possible for the threat actor to crack the cipher depending on the encryption method used.

There is a standard notation for the plaintext, ciphertext and keys. $C=E_K(P)$ is used to represent the encryption, $E$ of the plaintext, $P$ using the key, $K$ which results in the ciphertext, $C$. The decryption is defined as $P=D_K(C)$ where the plaintext, $P$, is the result of applying the decryption, $D$, with the key, $K$, on the ciphertext, $C$. 

\section{Encryption Techniques}
There are a number of Encryption Techniques used commonly.

\subsection{Substitution cipher}
In a \textit{substitution cipher}, each letter or group of letters is directly replaced by another letter or group of letters which disguises it. 

A well-known example of this is the Ceaser Cipher. 

\begin{example}{Substitution Cipher}
If we take the following substitution:

\begin{figure}[H]
\centering
\begin{BVerbatim}
Plaintext:     a b c d e f h g i j k l m n o p q r s t u v w x y z
Ciphertext:    Q W E R T Y U I O P A S D F G H J K L Z X C V B N M
\end{BVerbatim}
\caption{Substitution Matrix}
\end{figure}

We can see how we convert from plaintext to ciphertext.

For example, taking the plaintext \textit{attack} - we get the ciphertext \textit{QZZQEA}; or taking the plaintext \textit{london}, we get the Ciphertext \textit{SGFRGF}. 
\end{example}

Using a standard alphabet with 26 characters, assuming we only use lowercase letters, then there are $4 \times 10^{26}$ possible combinations. Which on a computer with one million CPU cores - can take up to 10,000 years to crack.

\subsection{Transposition Cipher}
In a \textit{transposition cipher}, we take a key and use this key to design a grid which we populate with our plaintext, working row-by-row. We then read the ciphertext from the grid reading column-by-column in alphabetical order of the key's letter.

\begin{example}{Transposition Cipher}
If we take the plaintext \textit{pleasetransferonemilliondollarstomyswissbankaccountsixtwotwo} and the key \textit{MEGABUCK}. 

We start by writing out the key at the top of the grid, and assigning a number to each column. In our case, the numbers are assigned in ascending order of the alphabet.

\begin{figure}[H]
\centering
\begin{BVerbatim}
M E G A B U C k
7 4 5 1 2 8 3 6
\end{BVerbatim}
\caption{Transposition Cipher Matrix with Key and Number shown}
\end{figure}

We can then take our plaintext and write that into the matrix working down the rows. We pad the end of the string to fill out the last row entirely, in our case we're using the start characters of the alphabet.

\begin{figure}[H]
\centering
\begin{BVerbatim}
M E G A B U C K
7 4 5 1 2 8 3 6
p l e a s e t r
a n s f e r o n
e m i l l i o n
d o l l a r s t
o m y s w i s s
b a n k a c c o
u n t s i x t w
o t w o a b c d
\end{BVerbatim}
\caption{Transposition Cipher Matrix with plaintext added}
\end{figure}

To get the ciphertext out of the matrix, we read from the matrix vertically in order of the column numbers: \textit{afllsksoselawaiatoossctclnmomantesilyntwrnntsowdpaedobuoeriricxb}. 

To decode the message, a similar process is followed: setup the matrix by writing the key, and the column numbers; then write in the ciphertext in columns based on the order of the numbers; then read rows to obtain the plaintext.
\end{example}

\section{Symmetric Encryption}
Symmetric Encryption is an encryption method in which the sender and receiver both use the same key to encode and decode the message. This is where it's alternative name, \textit{shared key encryption} comes from. 

Symmetric Encryption works through taking the plaintext input which is then encrypted using the key, $K$. The encryption algorithm will perform various substitutions or transformations on the plaintext, which will be key-dependent. This means that the same plaintext, with two different keys and the same encryption algorithm will produce two different ciphertexts. The ciphertext is then transmitted to the receiver. The receiver then decrypts the message using that pre-shared-key, $K$. The decryption algorithm is effectively the encryption algorithm run in reverse. This gives them the plaintext. 

We can see an example of a Symmetric Encryption in the DES encryption method.

\subsection{DES}
The \textit{Data Encryption Standard}, or DES, is a symmetric-key encryption algorithm which was developed in the 1970s and has been hugely influential in modern-day cryptography.

The plaintext input for DES is always 64-bits in length, and the key is always 56-bits. If the total plaintext needing to be encrypted using DES is longer than 64-bits then it gets chunked into 64-bit chunks so then the DES algorithm can process its 64-bit blocks. 

The DES algorithm works by taking the 56-bit key and generating 16 sub-keys from it. These 16 sub-keys are each used for their own round of encryption, therefore the DES algorithm encrypts the plaintext 16 times through a sequence iterating on the output of the previous as the input to the next. The keys are used in reverse order - meaning $K_{16}$ is used on the first iteration, $K_{15}$ on the second, and so on until $K_1$ is used on the final iteration. 

DES works through the 16 rounds of encryption following a modified \textit{Feistel Network} structure. This works by taking the plaintext and splitting it into two substrings of equal length. One half of the key is passed to the F-Function (Feistel Function) which performs Expansion, Key-Mixing, Substitution and Permutation operations on the input and that round's key. The output from the F-Function then gets XOR'd with the other half of the input string. The next round is then prepared by feeding the output from the XOR operation into the next F-Function, and the input to the current round's F-Function to the next rounds XOR. There are 16 rounds of this in total. The final ciphertext is created by concatenating the output of the final XOR with the output of the penultimate XOR operation (which fed into the F-Function, the output from which fed into the input to the final XOR operation). 

\begin{extlink}
There is a diagram explaining the Feistel Network in the slides on Moodle.
\end{extlink}


\subsection{3DES}
The \textit{Triple Data Encryption Standard}, or 3DES, is a symmetric-key encryption algorithm which apples the DES algorithm three times to each block. 

3DES works with three keys, $K_1$, $K_2$, and $K_3$. It will use $K_1$ on the first round of DES encrypting the data. Then the second round of DES will decrypt the data using $K_2$. The third and final round of DES will encrypt the data using $K_3$. The middle decryption doesn't return the data to the plaintext state, as $K_1 \neq K_2$. 

Decryption follows the same encryption process but in reverse: decrypting with $K_3$, encrypting with $K_2$ before decrypting with $K_1$. 

\subsection{AES}
The \textit{Advanced Encryption Standard}, or AES, is a symmetric-key encryption algorithm which was designed to replace DES.

AES supports three different key lengths: 128-bit, 192-bit and 256-bit. Similarly to how DES works on 64-bits of data at a time, AES works on 128-bit blocks of data and will perform $n$ rounds depending on the different key-length used. 128-bit keys get 10 rounds, 192-bit keys get 12 rounds and 256-bit keys get 14 rounds. 

\section{Asymmetric Encryption}
Asymmetric Encryption is an encryption method where the sender and receiver both use different keys to encode and decode the message. This is where it's alternative name, \textit{Public Key Encryption} comes form.

The sender encrypts the plaintext with the receivers public key to produce the ciphertext. The ciphertext is then transmitted over the network to the receiver. The receiver uses their private key to decrypt the message thus producing the plaintext. 

The public key of the receiver is made available to anyone who wants to send the receiver a message. The public key of anyone is restricted to them and them alone - leaking of a public key would mean that a threat actor could decode the message. Due to the receivers public keys being required to be able to send the receiver a message - senders will have as many public keys as the number of people they send messages to.

A major flaw with this model is that a threat actor could intercept the public-key encoded message and stop it from reaching the receiver. Whilst they couldn't read that message, they could spoof that message by sending their own payload encoded with the receivers public key. The receiver would receive this and decode it. 

We can see an example of the Asymmetric Encryption in the RSA algorithm. 

\subsection{RSA}
The \textit{Rivest-Shamir-Adlerman} cryptosystem, or RSA, is a public-key cryptosystem which was developed in 1973 at GHCQ. 

RSA works through taking two large prime numbers where their product is used to form the public key (along with other values used). The original prime numbers are kept secret. Then anyone can use the public key to encrypt the message. The message is transformed using mathematical operations which involve the public key. On the receiving end - only the corresponding private key can decrypt the message. The decryption process involves the original prime factors to reverse the encryption.

The RSA process can be formalised below:
\begin{enumerate}
    \item Chose two large primes, $p$ and $q$.
    \item $n=p\times q$ and $z=(q-1) \times (q-1)$
    \item Choose a number relatively prime to $z$ and call it $d$
    \item Find $e$ such that $e \times d = 1 \mod z$
    \item To encrypt a message, $P$, compute $C=P^e(\mod n)$
    \item To decrypt the ciphertext, $C$, compute $P=C^d(\mod n)$
    \item The public key is $(e, n)$ and the private key is $(d, n)$.
\end{enumerate}

\begin{example}{RSA}
We can see the above steps with real numbers substituted in below:
\begin{enumerate}
    \item Let $p=3$ and $q=11$
    \item Therefore $n=33$ and $z=20$
    \item Let $d=7$
    \item We can calculate $e$ using  $e \times 7 = \mod 20$ which sets $e=3$
    \item We can encrypt our message, for example $19$ by performing $C = 19^3(\mod 33)=28$
    \item We can decrypt the ciphertext, in this example $28$ by performing $P=28^7(\mod 33)=19$
    \item This means we know that the public key was $(3,33)$ and the private key was $(7,33)$.
\end{enumerate}
\end{example}

\begin{extlink}
There is a more fleshed-out example of the RSA process for the string ``SUZANNE'' in the slides on Moodle.
\end{extlink}
