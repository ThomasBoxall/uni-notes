\taughtsession{Lecture}{A4: Finite Automata}{2025-10-06}{15:00}{Janka}

This topic will continue into lecture A5 (next Monday).

\section{Models of Computation}
In this module we'll study different models of computation. These are theoretical ways of representing the computation which is going on within the computer for a given scenario. Examples include \textit{finite automata}, \textit{push-down automata} and \textit{Turing machines}. 

All these models have an \textit{input tape}. This is a continuous input string which is divided up into single string segments. The models can either accept or reject the input strings based on their rules. The set of all accepted strings over the alphabet is the language recognised by the model.

They have different types of memory - some may have finite and others infinite. Some models may have additional features.

\section{Finite Automata: An Introduction}
The most basic model of a computer is the \textit{Finite Automata} (FA). These have three components:
\begin{itemize}
    \item an \textit{input tape} which contains an input string over $\Sigma$
    \item a \textit{head} which reads the input string one symbol at a time
    \item some \textit{memory} which is a finite set of $Q$ states. The FA is always only in one state, called a \textit{current state} of the automaton
\end{itemize}

The \textit{program} of the FA defines how the symbols that are read change the current program.

Finite Automata are commonly represented as a transition graph (directed graph, cue flashbacks to DMAFP) because they are simpler to interpret than the formal definitions, which we will cover later.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=3cm, on grid, shorten >= 2pt, shorten <= 2pt]
        \node[initial, state] (0) {0};
        \node[state] (1) [above right of=0, yshift=-1cm] {1};
        \node[state] (2) [below right of=0, yshift=1cm] {2};
        \node[state, accepting] (3) [below right of=1, yshift=1cm] {3};

        \path[->, bend left=30] (0) edge [above] node [align=center] {$a$} (1);
        \path[->, bend right=30] (0) edge [above] node [align=center] {$b$} (2);
        \path[->, bend left=30] (1) edge [above] node [align=center] {$a$} (3);
        \path[->, bend right=30] (2) edge [above] node [align=center] {$b$} (3);
        \path[->] (1) edge [loop above] node [align=center] {$b$} (1);
        \path[->] (2) edge [loop below] node [align=center] {$a$} (2);
        \path[->] (3) edge [loop right] node [align=center] {$a,b$} (3);
    \end{tikzpicture}
    \caption{Example of Finite Automata}
    \label{fig:eg-fa}
\end{figure}

All \textit{finite automata} will have one \textit{initial} state and at least one \textit{final state} (denoted by a double circle). 

FAs work by starting in the initial state (0) and as we read off symbols in the string we move from state-to-state (vertex-to-vertex). If after reading the entire input string, the automaton is in the final state - the input string is accepted; if the automaton is not in the final state - the input string is rejected.

To define the function of a FA in mathematical terms - they read a finite-length input string over $\Sigma$, one symbol at a time. A FA is always in a \textit{state}, from the set of states $Q$. They begin in a designated initial (start) state, then on reading a symbol - the state changes which is called a transition. The new state depends on the current state and the symbol read in. There is no option to re-read the input symbols or to write them anywhere. At the end of the string, the machine either accepts the string if and only if its state is one of the final state, otherwise it gets rejected. The language of the automaton is the set of strings it accepts.

\begin{example}{Finite Automata Processing}
Looking at the Automata in Figure \ref{fig:eg-fa}, we can take the example input $abbbba$.

This would start in state 0, and travel to state 1, accepting the initial $a$. The automata then loops around from state 1 to state 1 accepting the $b$, which is repeated 4 times in total. The automata then takes the final $a$ and transitions from state 1 to 3. As we have processed all the input string and we are in the final state - the input string is accepted.

Below is a representation of the transitions taken by the automata to process the input string:
\[0 \rightarrow ^a\ 1 \rightarrow ^b\ 1 \rightarrow 1 ^b\ 1 \rightarrow 1 ^b\ 1 \rightarrow 1 ^b\ 1 \rightarrow 3 ^a\]
\end{example}


\subsection{State Transition Functions}
As much as pretty pictures of Finite Automata are all well and good - there is a second way to represent the transitions: using \textit{transition functions}.

Transition functions take the form:
\[T : Q \times \Sigma \rightarrow Q\]

Where $Q$ is the set of states and $\Sigma$ is the alphabet. We can see below an abstracted FA showing two states $i$ and $j$, with a single symbol $a$:

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=3cm, on grid, shorten >= 2pt, shorten <= 2pt]
        \node[initial, state] (0) {$i$};
        \node[state, accepting] (1) [right of=0] {$j$};
        
        \path[->] (0) edge [above] node [align=center] {$a$} (1);
    \end{tikzpicture}
    \caption{Abstracted FA with two states}
    \label{fig:fa-simple}
\end{figure}

In the above Finite Automata (Figure \ref{fig:fa-simple}) we can see how the transition function behaves. It is represented by $T(i, a) = j$, where $i, j \in Q$ and $a \in \Sigma$. 

\begin{example}{State Transition Functions}
If we take a more complex Finite Automata:
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=3cm, on grid, shorten >= 2pt, shorten <= 2pt]
        \node[initial, state] (0) {0};
        \node[state, accepting] (1) [right of=0] {1};
        \node[state] (2) [below right of=0, yshift=0.5cm, xshift=-0.5cm] {2};
        
        \path[->] (0) edge [above] node [align=center] {$a$} (1);
        \path[->] (0) edge [above] node [align=center] {$b$} (2);
        \path[->] (1) edge [loop right] node [align=center] {$a,b$} (1);
        \path[->] (2) edge [loop right] node [align=center] {$a,b$} (2);
    \end{tikzpicture}
    \caption{Example Finite Automata for Transition Functions}
    \label{fig:eg-fa-transitionfunction}
\end{figure}

We know it has a set of states: $Q = \{0, 1, 2\}$; a start state: $0$; and some final state(s): $1$.

We can take the transition function and see the possible transitions over $\Sigma = \{a,b\}$:
\begin{align*}
T(0,a) &= 1,\ T(0,b) = 2,\\
T(1,a) &= T(1,b) = 1\\
T(2,a) &= T(2,b) = 2
\end{align*}

\end{example}

\section{Deterministic Finite Automata}
\begin{define}
\item[Deterministic Finite Automata] a DFA over a finite alphabet $\Sigma$ is a finite directed graph with the property that each node emits one labelled edge for each distinct element of $\Sigma$
\end{define}
Except, hang on - isn't that what we've just seen so far. Yes, all the examples explored in this lecture so far have been DFAs; as there is exactly one option of transition for every state and every symbol, with every node in the graph having exactly one edge coming out for each possible input symbol. 

We can define DFA more formally in that a DFA \textit{accepts} a string $w$ over $\Sigma^*$ if there is a path from the start state to a final state such that $w$ is the concatenation of the edges of the path; otherwise the DFA \textit{rejects} $w$.

We also need to know that the set of all strings over $\Sigma$ accepted by a DFA $M$ is called the language of $M$ and is denoted as $L(M)$.

For any regular language, a DFA can be found which recognises it. This will be proved in the next lecture.

\begin{example}{Constructing a DFA for a given Regular Expression}
If we take the following regular expression:
\[(a + b)^* abb \textrm{\ over\ the\ alphabet\ } \Sigma = \{a, b\}\]

We can make an observation: the language is the set of strings that begin with anything but must end with the string $abb$ therefore we're looking for strings which have a particular patten to them. This method could be extended if we had a bigger alphabet, for example if we were looking for all strings ending in .tex, or .pdf. 

The challenge with this regular expression is that we won't know when the string will end. For example, the string could be $abb$, or $abababababb$. So to get around this, we will keep track of the last three symbols we've seen:
\begin{itemize}
    \item If in state 1: the last character was $a$
    \item If in state 2: the last two symbols were $ab$
    \item If in state 3: the last three wee $abb$
\end{itemize}

With this in mind, we can now construct the DFA.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=3cm, on grid, shorten >= 2pt, shorten <= 2pt]
        \node[initial, state] (0) {0};
        \node[state] (1) [right of=0] {1};
        \node[state] (2) [right of=1] {2};
        \node[state, accepting] (3) [right of=2] {3};
        
        \path[->] (0) edge [above] node [align=center] {$a$} (1);
        \path[->] (1) edge [above] node [align=center] {$b$} (2);
        \path[->] (2) edge [above] node [align=center] {$b$} (3);

        \path[->] (1) edge [loop above] node [align=center] {$b$} (1);
        \path[->] (2) edge [loop above] node [align=center] {$a$} (2);

        \path[->, bend left=30] (2) edge [above] node [align=center] {$a$} (1);
        \path[->, bend left=30] (3) edge [above] node [align=center] {$a$} (1.south);
        \path[->, bend left=30] (3.south) edge [below] node [align=center] {$b$} (0);

    \end{tikzpicture}
    \caption{DFA constructed from Regular Expression}
    \label{fig:eg-dfa-constructfromregex}
\end{figure}

\end{example}

\begin{extlink}
There are additional examples of DFA construction for a given regular expression in the slides available on Moodle.
\end{extlink}

\section{Non-Deterministic Finite Automata}
As we know with \textit{Deterministic} Finite Automata - we know exactly which state it is in and the path it took to get there for any given input string. To take the inverse of this - \textit{Non-Deterministic} Finite Automata (NFA) may have more than one option we can follow with the same input character, or there may be no option for a given input character. A NFA accepts and rejects strings in the same way as a DFA: accepting any string which ends up in its final state and rejecting everything else. 

A NFA over an alphabet $\Sigma$ is a finite transition graph with each node having zero or more edges. Each edge is labelled with either a letter from $\Sigma$ or $\Lambda$. Multiple edges may go from the same node with the same label, and some letters may not have an edge associated with them - strings following such paths are rejected. 

If an edge is labelled with the empty string $\Lambda$, then we can move to the next state (along the edge) without consuming an input letter - effectively we could be in either state and so the possible paths could branch. If there are two edges with the same label from one node, we can move along any of them.

\begin{example}{Construct a NFA for a given Regular Expression}
If we take the regular expression $ab + a^*a$. We can draw a NFA to recognise the language of it.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=3cm, on grid, shorten >= 2pt, shorten <= 2pt]
        \node[initial, state] (0) {0};
        \node[state] (1) [right of=0] {1};
        \node[state] (2) [below of=1, yshift=1cm] {2};
        \node[state, accepting] (3) [right of=1] {3};
        
        \path[->] (0) edge [above] node [align=center] {$a$} (1);
        \path[->] (0) edge [below] node [align=center] {$\Lambda$} (2);
        \path[->] (1) edge [above] node [align=center] {$b$} (3);
        \path[->] (2) edge [below] node [align=center] {$a$} (3);
        \path[->] (2) edge [loop below] node [align=center] {$a$} (2);
    \end{tikzpicture}
    \caption{Example Non-Deterministic Finite Automata}
    \label{fig:eg-nfa}
\end{figure}

In this NFA, we see that the ``upper'' path corresponds to $ab$ and the ``lower'' path to $a^*a$. We know this is a NFA because it has a $\Lambda$ edge and two $a-$edge from state 2.
\end{example}

Due to the non-deterministic nature of a NFA, the output of the transition functions are sets of states, $T:Q \times \Sigma \rightarrow P(Q)$. 

\begin{example}{NFA Transition Functions}
For example, if there are no edges from state $k$ labelled with $a$, we'll write:
\[T(k, a) = \emptyset\]

If there are three edges from state $k$ all labelled with $a$ going to states $i$, $j$, and $k$, we'll write:
\[T(k,a) = \{i, j, k\}\]

Looking back at Figure \ref{fig:eg-nfa} from the previous example, we can see there are four states 0, 1, 2, 3; where 0 is the starting state and 3 is the final state. From here we can see the transition functions:
\begin{align*}
T(0,a) &= \{1\}\\
T(0, \Lambda) &= \{2\}\\
T(1,b) &= \{3\}\\
T(3,a) &= \{2, 3\}
\end{align*}
\end{example}

\section{DFA vs. NFA}
All digital computers are deterministic. The usual mechanism for deterministic computers is to try one particular path and then to backtrack to the last decision point if that path proves to be poor. Parallel computers make non-determinism almost realisable; for example, we can let each process make a random choice at each branch point thereby exploring many possible trees. 



Generally speaking, NFAs are easier to construct and tend to be simpler with fewer states, for a given regular expression to recognise. However, DFAs are easier to operate as the path followed is always unique. Given that they recognise the same language, one is always able to find a DFA which recognises the language of a given NFA. DFAs are a subset of NFAs, so we only need to show that we can map any NFA into a DFA.

\begin{figure}[H]
\begin{minipage}[H]{0.45\textwidth}
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=3cm, on grid, shorten >= 2pt, shorten <= 2pt]
        \node[initial, state] (0) {0};
        \node[state, accepting] (1) [right of=0] {1};
        
        \path[->] (0) edge [above] node [align=center] {$a$} (1);
        \path[->] (0) edge [loop above] node [align=center] {$a$} (0);
    \end{tikzpicture}
    \caption{Example NFA for $a^*a$}
    \label{fig:nfa-fordfavsnfa}
\end{figure}
\end{minipage}\hfill
\begin{minipage}[H]{0.45\textwidth}
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=3cm, on grid, shorten >= 2pt, shorten <= 2pt]
        \node[initial, state] (0) {0};
        \node[state, accepting] (1) [right of=0] {1};
        
        \path[->] (0) edge [above] node [align=center] {$a$} (1);
        \path[->] (1) edge [loop above] node [align=center] {$a$} (1);
    \end{tikzpicture}
    \caption{Example DFA for $a^*a = aa^*$}
    \label{fig:dfa-fordfavsnfa}
\end{figure}
\end{minipage}    
\end{figure}

\section{Finding an Equivalent DFA for a given NFA}

We can prove the equivalence of NFAs and DFAs by showing how for any NFA by constructing a DFA which recognising the same language. Generally the DFA will have more possible states than the NFA; if the NFA has $n$ states then the DFA could have as many as $2^n$ states. 

\begin{example}{Converting a NFA to a DFA}
If we take the following NFA which recognises the language $(a+b)^*ab$ over the alphabet $\{a,b\}$
\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=3cm, on grid, shorten >= 2pt, shorten <= 2pt]
        \node[initial, state] (0) {$q_0$};
        \node[state] (1) [right of=0] {$q_1$};
        \node[state, accepting] (2) [right of=1] {$q_2$};
        
        \path[->] (0) edge [above] node [align=center] {$a$} (1);
        \path[->] (1) edge [above] node [align=center] {$b$} (2);
        \path[->] (0) edge [loop below] node [align=center] {$a,b$} (0);
    \end{tikzpicture}
    \caption{NFA To Be Converted}
    \label{fig:nfa-to-dfa-part1}
\end{figure}

\textbf{Step 1}

Begin in the NFA stat state; if it is connected to any others by $\Lambda$, the DFA start state could be a set of states.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=3cm, on grid, shorten >= 2pt, shorten <= 2pt]
        \node[initial, state] (0) {$\{q_0\}$};
        
    \end{tikzpicture}
    \caption{Start symbol of DFA}
    \label{fig:nfa-to-dfa-part2}
\end{figure}

\textbf{Step 2}

For each symbol - determine the set of possible NFA states you could be in after reading it. This set is a label for a new DFA state and is connected to the start by that symbol. In our example - the start state is $q_0$, but following an $a$ you could be in $q_0$ or $q_1$; following a $b$ you could only be in state $q_0$.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=3cm, on grid, shorten >= 2pt, shorten <= 2pt]
        \node[state, initial] (0) {$\{q_0\}$};
        \node[state] (1) [right of=0] {$\{q_0, q_1\}$};
        
        \path[->] (0) edge [above] node [align=center] {$a$} (1);
        \path[->] (0) edge [loop below] node [align=center] {$b$} (0);
    \end{tikzpicture}
    \caption{First step of converting NFA to DFA}
    \label{fig:nfa-to-dfa-part3}
\end{figure}

\textbf{Step 3}

Repeat step 2 for each new DFA state, exploring the possible results for each symbol until the system is closed. 

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=3cm, on grid, shorten >= 2pt, shorten <= 2pt]
        \node[state, initial] (0) {$\{q_0\}$};
        \node[state] (1) [right of=0] {$\{q_0, q_1\}$};
        \node[state, accepting] (2) [right of=1] {$\{q_0, q_2\}$};
        
        \path[->] (0) edge [above] node [align=center] {$a$} (1);
        \path[->] (1) edge [above] node [align=center] {$b$} (2);
        \path[->] (0) edge [loop below] node [align=center] {$b$} (0);
        \path[->] (1) edge [loop below] node [align=center] {$a$} (1);
        \path[->, bend right=30] (2.north west) edge [above] node [align=center] {$b$} (0.north east);
        \path[->, bend left=30] (2.south west) edge [below] node [align=center] {$a$} (1.south east);

    \end{tikzpicture}
    \caption{DFA showing all valid states}
    \label{fig:nfa-to-dfa-part4}
\end{figure}
The final state of the DFA are those that include an NFA final state in the set. 

If there is no transition for a state / a symbol in the NFA (non-acceptance of the string), create a new state in the DFA labelled $\emptyset$ and add loops for all symbols (a non-final trap state).
\end{example}

\subsection{Trap States}
\begin{define}
\item[Trap State] A state in which the machine cannot reach any final or accepting state. 
\end{define}

Trap States are needed in DFAs because to satisfy the requirement to be a DFA - every state must have an outgoing transition for every symbol in the alphabet. This is not an issue in NFAs because the Automaton assumes that if it can't find a suitable transition to use - the input string is invalid.


\begin{example}{Trap States in Action}
If we take the regular expression from our previous example, $(a+b)^*ab$ and expand the alphabet used to be $\{a, b, c\}$. This presents a problem as the input could contain $c$, but there's no suitable transitions the DFA can take for such a letter. We use a \textit{trap state} to catch this pesky $c$.

We can add a trap state to the DFA we created in the previous example. 

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=3cm, on grid, shorten >= 2pt, shorten <= 2pt]
        \node[state, initial] (0) {$\{q_0\}$};
        \node[state] (1) [right of=0] {$\{q_0, q_1\}$};
        \node[state, accepting] (2) [right of=1] {$\{q_0, q_2\}$};

        \node[state] (t) [below of=1, xshift=-1cm] {$\emptyset$};
                
        \path[->] (0) edge [above] node [align=center] {$a$} (1);
        \path[->] (1) edge [above] node [align=center] {$b$} (2);
        \path[->] (0) edge [loop below] node [align=center] {$b$} (0);
        \path[->] (1) edge [loop below] node [align=center] {$a$} (1);
        \path[->, bend right=30] (2.north west) edge [above] node [align=center] {$b$} (0.north east);
        \path[->, bend left=30] (2.south west) edge [below] node [align=center] {$a$} (1.south east);

        \path[->] (t) edge [loop below] node [align=center] {$a, b, c$} (t);
        \path[->] (0) edge [below] node [align=center] {$c$} (t);
        \path[->] (1.south west) edge [below] node [align=center] {$c$} (t);
        \path[->] (2.south) edge [below] node [align=center] {$c$} (t);

    \end{tikzpicture}
    \caption{DFA showing a Trap State}
    \label{fig:dfa-showing-trap-state}
\end{figure}
\end{example}