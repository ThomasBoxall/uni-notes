\taughtsession{Lecture}{A10: Computing with TMs and Alt. Definitions}{2025-11-03}{15:00}{Janka}

Caffeine break later, we're back at them friendly lil' Turing Machines...

\section{Computing Functions}
For a given input string, $x$, we can construct a TM which will do some computation following its instructions. This gives the output of a string $y$ on the tape of the TM when it halts.

From this we can see that we can define a \textit{partial} function $T(x) = y$ for all strings $x$ for which the TM halts. This means that the TM can compute values of functions on strings. 

This is great for strings, but what about integers? We represent non-negative integers in other ways, for example $n$ by a string of $n+1$ (or $n$) 1s or in binary format. 

\begin{example}{TM for adding 2}
If we take a natural number $n$ to be our input, we can compute $n+2$ as our output.

For the purposes of this example, we'll represent natural numbers in unary form (for example 3=111, or 5=11111) and 0 will be represented by the empty symbol ($\square$).

The plan:
\begin{itemize}
    \item Move tape head to the left of the first 1 (if it exists)
    \item Change that empty cell to a 1
    \item Move left and repeat
    \item Halt
\end{itemize}

We'll need 3 states: 0 (initial), 1 and Halt as well as three instructions to make this happen.

\begin{align*}
    (1):&\ (0,1,1,L,0)  && \textrm{move left to blank cell}\\
    (2):&\ (0,\square, 1, L, 1) && \textrm{Write 1 into cell and move left}\\
    (3):&\ (1,\square, 1, S, Halt) && \textrm{Write 1 into cell and halt}
\end{align*}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=5cm, on grid, shorten >= 2pt, shorten <= 2pt]
        \node[state, initial] (0) {$0$};
        \node[state] (1) [right of=0] {$1$};
        \node[state, accepting] (H) [right of=1] {$H$};
        
        \path[->] (0) edge [above] node [align=center] {$\displaystyle \frac{\square}{1,L}$} (1);
        \path[->] (1) edge [above] node [align=center] {$\displaystyle \frac{\square}{1,S}$} (H);

        \path[->] (0) edge [loop above] node [align=center] {$\displaystyle \frac{1}{1,L}$} (0);
        
    \end{tikzpicture}
    \caption{TM designed for adding 2}
\end{figure}

We can now see the instantaneous description for adding 2 to a given input string:
\begin{align*}
&\textrm{State 0:} && \square\ \underline{1}\ 1\ 1\ \square && \textrm{begin in state 0}\\
&\textrm{State 0:} && \underline{\square}\ 1\ 1\ 1\ \square && \textrm{(1)}\\
&\textrm{State 1:} && \underline{\square}\ 1\ 1\ 1\ 1\ \square && \textrm{(2)}\\
&\textrm{Halt:} && \square\ \underline{1}\ 1\ 1\ 1\ 1\ \square && \textrm{(3)}\\
\end{align*}
\end{example}

\begin{extlink}
There is a second example of a Turing Machine for Computing Functions, this time for adding 1 in binary available in the Lecture A10 slides on Moodle.
\end{extlink}

\section{Non-deterministic Turing Machines}
In a similar to PDA (an sort of similar to that of NFA), a TM's non-determinism presents through having multiple possible outputs for one input configuration. The non-deterministic TM is like the TM but with finite number of choices of moves and may have more than 1 move with the same input state \& symbol. The non-deterministic TM accepts the input $w$ if there is at least one computation that halts normally for the input $w$. 

Non-determinism is more powerful than determinism for pushdown automata. However it makes no different for finite automata. In a similar way, deterministic and non-deterministic Turing Machines posses the same power. We can therefore derive the theorem: if a non-deterministic Turing Machine accepts a language, $L$, then there is a deterministic Turing Machine that also accepts $L$. 

Both deterministic and non-deterministic Turing Machines accept ths same family of languages: recursive enumerable languages generated by the unrestricted grammars.

\section{Alternative Definitions}
There are a number of other similar machines which might look more or less powerful than a Turing Machine but can be seen to be equivalent in power to the simple Turing Machine. This can be achieved by adding more tapes, more control units, etc.

We show the equivalence of these Turing Machine'nts and Turing Machines by describing how a simple one-tape Turing Machine can be used to emulate them and vice-versa. 

\subsection{Two Stack PDA}
This variation has two stacks in lieu of an input tape, both still connected to the Control Node. The right half of the tape is kept on one stack, while the left half kept on the other. As we move along the tape we pop characters off one stack and push them onto the other.

\subsection{Semi-Infinite Tape}
In this variation, we are presented with an infinite tape which is only infinite in one direction. We can emulate the standard TM by splitting the cells into two groups, alternating as we go down the tape. One group represents the left half of the infinite tape and the other group represents the right half. 

\subsection{Multi-Track}
A multi-track Turing Machine has $k$ tracks on the same tape which are read and written at the same time. A multi-track TM can simulate a standard TM when all bar the first track are ignored. A standard TM (with $\Sigma'$) can simulate a multi-track TM (with $\Sigma$) if we map every order pair $[x_1, x_2, \ldots, x_k]$ of symbols from $\Sigma$ to a unique symbol in $\Sigma'$ where $|\Sigma'| = |\Sigma|^k$. 

\subsection{Multi-Tape}
In the multi-tape Turing machine, there are $k$ tapes with $k$ tape heads each moving independently. This is a generalisation of the multi-track Turing Machine. Each TM has its own read-write head but the state is common for all.

In each step, transition, the TM reads the symbols scanned by all heads. Then depending on the read symbols and the current state - each head writes, moves R or L and the control unit enters a new state. Actions of the heads are independent of each other. 

\begin{example}{Multiplying two numbers with Multi-Tape Turing Machine}
If we take the example that we want to multiply two numbers, each of which represented as a unary string of ones, to get a third number. This would be difficult to do with a simple Turing machine but is fairly straight forward with a three-tape machine.

We can use a three-tape Turing Machine, each with a specific data item to represent:
\begin{itemize}
    \item Tape 1: the first number in the multiplication (i.e. 3)
    \item Tape 2: the second number in the multiplication (i.e 4)
    \item Tape 3: the output
\end{itemize}

We start by checking whether either number is zero
\begin{align*}
&(0,(\square, \square, \square), (\square, \square, \square), (S,S,S), Halt) && \textrm{Both are zero}\\
&(0,(\square, 1, \square), (\square, 1, \square), (S,S,S), Halt) && \textrm{First is zero}\\
&(0,(1, \square, \square), (1, \square, \square), (S,S,S), Halt) && \textrm{Second is zero}\\
&(0,(1, 1, \square), (1, 1, \square), (S,S,S), 1) && \textrm{Both are non-zero}\\
\end{align*}

Add the number on the second tape to the third tape
\begin{align*}
&(1, (1, 1, \square), (1, 1, 1), (S, R, R), 1) && \textrm{Copy}\\
&(1, (1, \square, \square), (1, \square, \square), (S, L, S), 2) && \textrm{Done Copying}\\
\end{align*}

Move the tape head of the second tape back to the left end of the number; move the tape head of the first number one cell to the right
\begin{align*}
&(2, (1, 1, \square), (1, 1, \square), (S,L,S),2) && \textrm{Move to the left end}\\
&(2, (1,  \square, \square), (1, \square, \square), (R,R,S),3) && \textrm{Both types to the right one cell}\\
\end{align*}

Check the first tape head to see if all the additions have been performed
\begin{align*}
& (3, (\square, 1, \square), (\square, 1, \square), (S,S,L), Halt) && \textrm{Done}\\
& (3, (1, 1, \square), (1, 1, \square), (S,S,S), 1) && \textrm{Do another add}\\
\end{align*}

\end{example}

Every Multi-Tape Turing Machine has an equivalent single tape TM. If $M$ has $k$ tapes, $M'$ simulates the effect of $k$ tapes by storing the information on its single tape. It uses a new symbol \# as a delimiter to separate the contents of the different tapes (marks the left and the right portions of the tape). $M'$ also must keep track of the locations of the heads on each tape. It writes a tape symbol with  dot above it to mark where the head on that tape would be. Dotted symbols are simply new symbols added to the tape alphabet. 

If the movement of one T's tape head causes $M'$s tape head to bump into either $\square$ or \# then that side of the tape must be moved to make room for a new cell. 

\subsection{Multi-Head}
The Multi-Head Turing Machine has one tape with many tape heads moving independently. Two heads are usually better than one, but not in the case of the TM as only one can be active at a given time. A particular head is associated with each state - which is part of the instructions. 

\subsection{Off-Line Turing Machine}
This is a Turing Machine with two tapes, where one tape is a read-only version of the input.

\subsection{Multi-Dimensional Tape}
This is a Turing Machine which has one tape where the tape may extend in two more more dimensions. 

\section{Linear Bounded Automata}
The final piece of the puzzle...

The Linear Bounded Automaton (LBA) is a Turing machine which can only use a tape which is the size of the initial input, ie it cannot use any more tape than the size of the initial input. This type of machine recognises exactly the family of context-free languages. We won't cover these in any more detail.

So excluding the languages which can't be described by a grammar - we've done it. We've identified a type of machine which can recognise each of our types of language as prescribed in the Chomsky Hierarchy. 

\begin{table}[H]
    \centering
    {\RaggedRight
    \begin{tabular}{p{0.3\textwidth} p{0.3\textwidth} p{0.3\textwidth}}
    \thead{Language Family} & \thead{Grammars} & \thead{Recognition Machine}\\
    Regular Languages & Regular Grammar & Deterministic Finite Automata (DFA) \& Non-deterministic Finite Automata (NFA) \\
    \hline
    Context-Free Languages & Context Free Grammars & Non-deterministic Pushdown Automata (NPDA) \\
    \hline
    Context Sensitive Languages & Context Sensitive Grammars & Linear Bounded Automata (LBA)\\
    \hline
    Recursive Enumerable Languages & Unrestricted Grammars & Turing Machines (TM)\\
    \hline
    \end{tabular}
    } % end of rr     
    \caption{Chomsky Languages and Recognition Machines}
\end{table}